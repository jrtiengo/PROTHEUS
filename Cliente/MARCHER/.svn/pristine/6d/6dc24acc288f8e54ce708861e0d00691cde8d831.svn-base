#INCLUDE "PROTHEUS.CH"
#INCLUDE "TBICONN.CH"
#INCLUDE "TOPCONN.CH"
/*
{Protheus.doc} MARA060
Programa que fará a atualização das tabelas na Mercos via WebService
@type User function
@author Jean Rehermann - Solutio
@since 15/11/2021
*/
User Function MARA060()

	Private lBlind   := IsBlind()
	Private bProcInc := {|| Iif( !lBlind, IncProc(), 0 ) }
	Private aLogMerc := {}

	If lBlind
		EnvMercos() // Criar o ambiente de execução
	EndIf

	// Atualizar os produtos
	//Processa({|| ApiProdMerc() }, "Integrando produtos...")

	// Atualizar os clientes
	//Processa({|| ApiCliMerc() }, "Integrando clientes...")

	// Atualizar as condições de pagamento
	Processa({|| ApiPagMerc() }, "Integrando condição de pagamento...")

	If lBlind
		RpcClearEnv()
	EndIf

Return

/*
Cria o ambiente para a execução do processo no schedule
*/
Static Function EnvMercos()

	Local cRpcEmp		:= "01"	     // Empresa
	Local cRpcFil		:= "01"	     // Filial Principal
	Local cEnvMod		:= "FAT"     // Modulo
	Local cFunName		:= "MARA060" // Funcao
    Local aTables 		:= {"SB1","SA1"}

	RPCSetType(3) //Define que o ambiente nao consome licenca
	RpcSetEnv( cRpcEmp , cRpcFil , , , cEnvMod, cFunName , aTables, , , ,  )

Return Nil

/*
Efetua a atualização dos produtos no site da Mercos
*/
Static Function ApiProdMerc()

	Local cSql      := ""
	Local cJson     := ""
	Local cDescProd := ""
	Local cMetodo   := ""
	Local nPos      := 0
	Local nTotal    := 0
	Local aRet      := {}
	Local nSleep    := SuperGetMv("ES_DLYWSME", .F., 250) // Milissegundos de delay entre as requisições ao webservice
	Local cAliasSB1 := GetNextAlias()

	// https://mercos.docs.apiary.io/#reference/0/produtos/incluir-um-produto?console=1

	cSql := "SELECT DA1_PRCVEN, B1_COD, B1_DESC, B1_IDMERCO, B1_POSIPI, "
	CsQL += " B1_UM, B1_IPI, B1_PESO, SB1.R_E_C_N_O_ RECNO "
	cSql += " FROM "+ RetSqlName("DA1") +" DA1, "+ RetSqlName("SB1") +" SB1 "
	cSql += " WHERE DA1_CODPRO = B1_COD "
	cSql += " AND DA1_CODTAB = '504' "
	cSql += " AND B1_DTMERCO = ' ' "
	cSql += " AND DA1.D_E_L_E_T_ = ' ' "
	cSql += " AND SB1.D_E_L_E_T_ = ' ' "

	dbUseArea( .T., "TOPCONN", TCGenQry( NIL, NIL, cSql ), cAliasSB1, .F., .T. )
	//TCQuery cSql New Alias cAliasSB1

	If !lBlind
		Count To nTotal
		ProcRegua( nTotal )
	EndIf

	(cAliasSB1)->( dbGoTop() )

	While !(cAliasSB1)->( Eof() )

		cDescProd := fRemCar( (cAliasSB1)->B1_DESC )

		cJson := '{'
		cJson += '"codigo": "'+ AllTrim( (cAliasSB1)->B1_COD ) +'",'
		cJson += '"nome": "'+ cDescProd +'",'
		cJson += '"preco_tabela": '+ IIf( (cAliasSB1)->DA1_PRCVEN > 0, cValToChar( (cAliasSB1)->DA1_PRCVEN ), 'null' ) +','
		cJson += '"comissao": '+ IIf( (cAliasSB1)->B1_COMIS1 > 0, cValToChar( (cAliasSB1)->B1_COMIS1 ), 'null' ) +','
		cJson += '"ipi": '+ IIf( (cAliasSB1)->B1_IPI > 0, cValToChar( (cAliasSB1)->B1_IPI ), 'null' ) +','
		cJson += '"tipo_ipi": "P",'
		cJson += '"moeda": "0",'
		cJson += '"unidade": "'+ AllTrim( (cAliasSB1)->B1_UM ) +'",'
		cJson += '"peso_bruto": '+ cValToChar( (cAliasSB1)->B1_PESO ) +','
		cJson += '"codigo_ncm": "'+ AllTrim( (cAliasSB1)->B1_POSIPI ) +'"'
		cJson += '}'

		// Verifica se o produto já existe no Mercos, para fazer um PUT ao invés de um POST
		cMetodo := Iif( Empty( (cAliasSB1)->B1_IDMERCO ), "POST", "PUT" )

		// Faz a requisição no webservice
		aRet := U_SndJSON( cMetodo, "/api/v1/produtos", cJson )
		Sleep( nSleep )

		If aRet[ 1 ] == "201" .And. Len( aRet[ 2 ] ) > 0

			nPos := aScan( aRet[2], {|o| Upper( o[ 1 ] ) == "MEUSPEDIDOSID"} )

			If nPos > 0

				SB1->( dbGoTo( (cAliasSB1)->RECNO ) )
				SB1->( RecLock("SB1", .F.) )
				SB1->B1_IDMERCO := Val( aRet[2, nPos, 2 ] )
				SB1->B1_DTMERCO := cValToChar( Year( Date() ) ) +'-'+ StrZero( Month( Date() ), 2 ) +'-'+ StrZero( Day( Date() ), 2 ) +' '+ Time()
				SB1->( MsUnLock() )

			EndIf

		EndIf

		Eval( bProcInc )

		(cAliasSB1)->( dbSkip() )

	End

	(cAliasSB1)->( dbCloseArea() )

Return

/*
Efetua a atualização dos clientes no site da Mercos
*/
Static Function ApiCliMerc()

	Local cSql      := ""
	Local cMetodo   := ""
	Local aRet      := {}
	Local aEndStr   := {}
	Local nPos      := 0
	Local nTotal    := 0
	Local nSleep    := SuperGetMv("ES_DLYWSME", .F., 250) // Milissegundos de delay entre as requisições ao webservice
	Local cAliasSA1 := GetNextAlias()

	cSql := "SELECT A1_NOME, A1_COD, A1_END, A1_EST, A1_NOME, A1_NREDUZ, A1_PESSOA,"
	cSql += " A1_CGC, A1_INSCR, A1_CEP, A1_BAIRRO, A1_MUN, A1_EMAIL, A1_TEL, A1_DDD, A1_FAX,"
	cSql += " A1_IDMERCO, A1_DTMERCO, R_E_C_N_O_ RECNO "
	cSql += " FROM "+ RetSqlName("SA1")
	cSql += " WHERE D_E_L_E_T_ = ' ' "
	cSql += "   AND A1_MSBLQL <> '1' "
	cSql += "   AND A1_DTMERCO = ' ' "

	dbUseArea( .T., "TOPCONN", TCGenQry( NIL, NIL, cSql ), cAliasSA1, .F., .T. )
	//TCQuery cSql New Alias cAliasSA1

	If !lBlind
		Count To nTotal
		ProcRegua( nTotal )
	EndIf

	(cAliasSA1)->( dbGoTop() )

	While !(cAliasSA1)->( Eof() )

		// Obtem a estrutura do endereço [ RUA, nNUMERO, cNUMERO, COMPLEMENTO ]
		aEndStr := FisGetEnd( (cAliasSA1)->A1_END, (cAliasSA1)->A1_EST )

		cJson := '{'
		cJson += '"razao_social": "'+  AllTrim( fRemCar( (cAliasSA1)->A1_NOME ) ) +'",'
		cJson += '"nome_fantasia": "'+ AllTrim( fRemCar( (cAliasSA1)->A1_NREDUZ ) ) +'",'
		cJson += '"tipo": "'+          (cAliasSA1)->A1_PESSOA +'",'
		cJson += '"cnpj": "'+          (cAliasSA1)->A1_CGC +'",'

		If !Empty( (cAliasSA1)->A1_INSCR )
			cJson += '"inscricao_estadual": "'+ AllTrim( (cAliasSA1)->A1_INSCR ) +'",'
		EndIf

		cJson += '"rua": "'+ AllTrim( fRemCar( aEndStr[ 1 ] ) ) +'",'
		cJson += '"numero": "'+ Iif( !Empty( aEndStr[ 3 ]), fRemCar( AllTrim( aEndStr[ 3 ] ) ), "SN" ) +'",'

		If !Empty( aEndStr[ 4 ] )
			cJson += '"complemento": "'+ AllTrim( fRemCar( aEndStr[ 4 ] ) ) +'",'
		EndIf

		cJson += '"cep": "'+    (cAliasSA1)->A1_CEP +'",'
		cJson += '"bairro": "'+ AllTrim( fRemCar( (cAliasSA1)->A1_BAIRRO ) ) +'",'
		cJson += '"cidade": "'+ AllTrim( (cAliasSA1)->A1_MUN ) +'",'
		cJson += '"estado": "'+ (cAliasSA1)->A1_EST +'",'

		If !Empty( (cAliasSA1)->A1_EMAIL ) .And. Len( AllTrim( (cAliasSA1)->A1_EMAIL ) ) > 10 .And. At( "@", (cAliasSA1)->A1_EMAIL ) > 0
			cJson += '"emails": [{"email": "'+ AllTrim( (cAliasSA1)->A1_EMAIL ) +'"}],'
		EndIf

		If !Empty( (cAliasSA1)->A1_TEL )
			cJson += '"telefones": ['
			cJson += '{"numero": "('+ AllTrim((cAliasSA1)->A1_DDD) +')'+ AllTrim((cAliasSA1)->A1_TEL) +'"}'
			If !Empty( (cAliasSA1)->A1_FAX )
				cJson += ','
				cJson += '{"numero": "('+ AllTrim((cAliasSA1)->A1_DDD) +')'+ AllTrim((cAliasSA1)->A1_FAX) +'"}'
			EndIf
			cJson += '],'
		EndIf
		cJson += '"excluido": false'
		cJson += '}'

		// Verifica se o cliente já existe no Mercos, para fazer um PUT ao invés de um POST
		cMetodo := Iif( Empty( (cAliasSA1)->A1_IDMERCO ), "POST", "PUT" )

		cJson := '{"razao_social": "HENRICUS JOHANNES  M. A.","nome_fantasia": "HENRICUS JOHANNES","tipo": "F","cnpj": "22016945087   ","inscricao_estadual": "0891118101","rua": "ESQUINA BECK - GRANJA ZEELANDIA","numero": "SN","cep": "98300000","bairro": "ESQUINA BECK","cidade": "PALMEIRA DAS MI","estado": "RS","emails": [{"email": "compras@granjaguara.com.br"}],"telefones": [{"numero": "(55)33753081"}],"excluido": false}'

		aRet := U_SndJSON( cMetodo, "/api/v1/clientes", cJson )
		Sleep( nSleep )

		If aRet[ 1 ] == "201" .And. Len( aRet[ 2 ] ) > 0

			nPos := aScan( aRet[2], {|o| Upper( o[ 1 ] ) == "MEUSPEDIDOSID"} )

			If nPos > 0

				SA1->( dbGoTo( (cAliasSA1)->RECNO ) )
				SA1->( RecLock("SA1", .F.) )
				SA1->A1_IDMERCO := Val( aRet[2, nPos, 2 ] )
				SA1->A1_DTMERCO := cValToChar( Year( Date() ) ) +'-'+ StrZero( Month( Date() ), 2 ) +'-'+ StrZero( Day( Date() ), 2 ) +' '+ Time()
				SA1->( MsUnLock() )

			EndIf

		EndIf

		Eval( bProcInc )

		(cAliasSA1)->( dbSkip() )

	End

	(cAliasSA1)->( dbCloseArea() )

Return

/*
Efetua a atualização das condições de pagamento no site da Mercos
*/
Static Function ApiPagMerc()

	Local cSql      := ""
	Local cJson     := ""
	Local cDesc     := ""
	Local nPos      := 0
	Local aRet      := {}
	Local nSleep    := SuperGetMv("ES_DLYWSME", .F., 250) // Milissegundos de delay entre as requisições ao webservice
	Local cCondPag  := SuperGetMv("ES_CNPGMER", .F., "'508','509','510','511','512','513','514','999'") // Condições de pagamento a serem integradas
	Local cAliasSE4 := GetNextAlias()

	// https://mercos.docs.apiary.io/#reference/0/produtos/incluir-um-produto?console=1

	cSql := "SELECT E4_CODIGO, REPLACE( REPLACE(E4_DESCRI,'/',','), '>', '' ) E4_DESCRI, R_E_C_N_O_ RECNO "
	cSql += " FROM "+ RetSqlName("SE4")
	cSql += " WHERE D_E_L_E_T_ = ' ' "
	cSql += "   AND E4_CODIGO IN ("+ cCondPag +") "
	cSql += "   AND E4_DTMERCO = ' ' "
	cSql += " ORDER BY E4_DESCRI "

	dbUseArea( .T., "TOPCONN", TCGenQry( NIL, NIL, cSql ), cAliasSE4, .F., .T. )

	While !(cAliasSE4)->( Eof() )

		cDesc := fRemCar( (cAliasSE4)->E4_DESCRI )

		cJson := '{'
		cJson += '"nome": "'+ (cAliasSE4)->E4_CODIGO +'-'+ cDesc +'"'
		cJson += '}'

		// Faz a requisição no webservice
		aRet := U_SndJSON( "POST", "/api/v1/condicoes_pagamento", cJson )
		Sleep( nSleep )

		If aRet[ 1 ] == "201" .And. Len( aRet[ 2 ] ) > 0

			nPos := aScan( aRet[2], {|o| Upper( o[ 1 ] ) == "MEUSPEDIDOSID"} )

			If nPos > 0

				SE4->( dbGoTo( (cAliasSE4)->RECNO ) )
				SE4->( RecLock("SE4", .F.) )
				SE4->E4_IDMERCO := Val( aRet[2, nPos, 2 ] )
				SE4->E4_DTMERCO := cValToChar( Year( Date() ) ) +'-'+ StrZero( Month( Date() ), 2 ) +'-'+ StrZero( Day( Date() ), 2 ) +' '+ Time()
				SE4->( MsUnLock() )

			EndIf

		EndIf

		(cAliasSE4)->( dbSkip() )

	End

	(cAliasSE4)->( dbCloseArea() )

Return


/*
Faz o envio do Json para o webservice e resebe o retorno
*/
User Function SndJSON( cMetodo, cUri, cJson )

	Local oResult
	Local lOk       := .T.
	Local nLoop     := 0
	Local cResult   := ""
	Local cHttpCode := ""
	Local cJsonTxt  := ""
	Local cMsgErr   := "Integração Mercos / Marcher - "
	Local aHeader   := {}
	Local aResult   := {}
	Local cUrl      := SuperGetMv("ES_MURLAPI", .F., "") // URL da API da Mercos para WebServices
	Local cTokenApp := SuperGetMv("ES_MAPPTOK", .F., "") // ApplicationToken  Em Base64
	Local cTokenCpn := SuperGetMv("ES_MCPNTOK", .F., "") // CompanyToken  Em Base64

	Private oRest
	Private oJson

	DEFAULT cMetodo := ""
	DEFAULT cUri    := ""
	DEFAULT cJson   := ""

	// Validações dos parâmetros
	If Empty( cUrl )
		cMsgErr += "URL não informada, parâmetro ES_MURLAPI"
		lOk := .F.
	EndIf

	If lOk .And. Empty( cMetodo )
		cMsgErr += "Método da requisição não passado para a função (PUT/POST/GET)"
		lOk := .F.
	EndIf

	If lOk .And. cMetodo $ "PUT/POST" .And. Empty( cJson )
		cMsgErr += "JSON não passado para a função quando POST ou PUT"
		lOk := .F.
	EndIf

	If lOk .And. Empty( cTokenApp )
		cMsgErr += "ApplicationToken não informado, parâmetro ES_MAPPTOK"
		lOk := .F.
	Else
		// Decodifica o ApplicationToken
		cTokenApp := Decode64( cTokenApp )
	EndIf

	If lOk .And. Empty( cTokenCpn )
		cMsgErr += "CompanyToken não informado, parâmetro ES_MCPNTOK"
		lOk := .F.
	Else
		// Decodifica o CompanyToken
		cTokenCpn := Decode64( cTokenCpn )
	EndIf

	If lOk

		// Cria o objeto Rest que fará a interação com o webservice
		oRest := FWRest():New( cUrl )

		// Cria o objeto Json para receber o texto e validar as sintaxes
		oJson := JsonObject():New()

		If cMetodo $ "PUT/POST"
			// Efetua a validação do Json que foi passado
			cResult := oJson:FromJson( cJson )

			// Verifico erros
			If ValType( cResult ) <> "U"
				cMsgErr += "Erro na validação do Json: "+ cResult
				lOk := .F.
			Else
				cJsonTxt := cJson
			EndIf
		EndIf

	EndIf

	If lOk

		// Setar o caminho da requisição
		oRest:setPath( cUri )

		// Definir os cabeçalhos
		aAdd( aHeader, "Content-Type:application/json" )
		aAdd( aHeader, "ApplicationToken:"+ cTokenApp )
		aAdd( aHeader, "CompanyToken:"+ cTokenCpn )

		// Definir o método: POST (inclusão), GET (requisição), PUT (alteração)
		If cMetodo == "POST"

			oRest:SetPostParams( cJsonTxt )  // Seto o JSON para o POST
			lOk := oRest:Post( aHeader )     // Executo o POST no serviço
			cHttpCode := oRest:GetHTTPCode() // Verifica o código de retorno da requisição HTTP

			If !lOk
				cMsgErr += "Erro no POST : "+ DecodeUTF8( oRest:getLastError() ) // Quando dá certo retorna '201 Created'
				cResult := AllTrim( DecodeUTF8( oRest:getResult() ) ) // Mensagens de erro

				If At( '"erros":', cResult ) > 0
					oJson:FromJson( cResult )
					If aScan( oJson:GetNames(), { |o| o == "erros" } ) > 0
						aResult := oJson:GetJSonObject('erros')
						If Len( aResult ) > 0
							For nLoop := 1 To Len( aResult )
								cMsgErr +=  CHR(13) + CHR(10) +"Campo: "+ aResult[nLoop]["campo"] + CHR(13) + CHR(10)
								cMsgErr += "Mensagem: "+ aResult[nLoop]["mensagem"]
							Next
						EndIf
					EndIf
					aResult := {}
					cMsgErr := OemToAnsi( cMsgErr )
					cResult := cMsgErr
				EndIf
			Else
				// Obtem o Response da requisição realizada
				oResult := Iif( ValType( oRest:oResponseH ) == "O", oRest:oResponseH, Nil )
				aResult := Iif( oResult != Nil, oRest:oResponseH:aHeaderFields, {} )
				cResult := AllTrim( DecodeUTF8( oRest:getResult() ) )
			EndIf

		Elseif cMetodo == "GET"

			lOk := oRest:Get( aHeader )     // Executo o GET no serviço
			cHttpCode := oRest:GetHTTPCode() // Verifica o código de retorno da requisição HTTP

			If !lOk
				cMsgErr += "Erro no GET : "+ DecodeUTF8( oRest:getLastError() ) // Quando dá certo retorna '201 Created'
				cResult := AllTrim( DecodeUTF8( oRest:getResult() ) ) // Mensagens de erro

				If At( '"erros":', cResult ) > 0
					oJson:FromJson( cResult )
					If aScan( oJson:GetNames(), { |o| o == "erros" } ) > 0
						aResult := oJson:GetJSonObject('erros')
						If Len( aResult ) > 0
							For nLoop := 1 To Len( aResult )
								cMsgErr +=  CHR(13) + CHR(10) +"Campo: "+ aResult[nLoop]["campo"] + CHR(13) + CHR(10)
								cMsgErr += "Mensagem: "+ aResult[nLoop]["mensagem"]
							Next
						EndIf
					EndIf
					aResult := {}
					cMsgErr := OemToAnsi( cMsgErr )
					cResult := cMsgErr
				EndIf
			Else
				// Obtem o Response da requisição realizada
				oResult := Iif( ValType( oRest:oResponseH ) == "O", oRest:oResponseH, Nil )
				aResult := Iif( oResult != Nil, oRest:oResponseH:aHeaderFields, {} )
				cResult := AllTrim( DecodeUTF8( oRest:getResult() ) )
			EndIf

		ElseIf cMetodo == "PUT"

		Else
			cMsgErr := "O método enviado não é suportado: "+ cMetodo
			lOk := .F.
		EndIf

	EndIf

	// Em caso de erro exibe a mensagem, no console ou popup
	If !lOk
		If lBlind
			ConOut( cMsgErr )
		Else
			ConOut( cMsgErr )
		EndIf
	Else
		ConOut( cResult )
	EndIf

	FreeObj( oRest )
	FreeObj( oJson )

Return( { cHttpCode, aResult, cResult } )

// Função que faz a eliminação de caracteres especiais de uma string
Static Function fRemCar( cTexto )

	Local cTextOk := cTexto

	cTextOk := AllTrim( FwNoAccent( cTextOk ) )
	cTextOk := StrTran( cTextOk, "³", "" )
	cTextOk := StrTran( cTextOk, "²", "" )
	cTextOk := StrTran( cTextOk, "º", "" )
	cTextOk := StrTran( cTextOk, "ª", "" )
	cTextOk := StrTran( cTextOk, "$", "" )
	cTextOk := StrTran( cTextOk, "%", "" )
	cTextOk := StrTran( cTextOk, "&", "" )
	cTextOk := StrTran( cTextOk, "'", "" )
	cTextOk := StrTran( cTextOk, "~", "" )
	cTextOk := StrTran( cTextOk, "/", "" )
	cTextOk := StrTran( cTextOk, "\", "" )
	cTextOk := StrTran( cTextOk, "#", "" )
	cTextOk := StrTran( cTextOk, "*", "" )
	cTextOk := StrTran( cTextOk, "+", "" )
	cTextOk := StrTran( cTextOk, '"', '' )
	cTextOk := StrTran( cTextOk, "", "" )
	cTextOk := StrTran( cTextOk, "á", "" )
	cTextOk := StrTran( cTextOk, "Á", "" )
	cTextOk := StrTran( cTextOk, "à", "" )
	cTextOk := StrTran( cTextOk, "À", "" )
	cTextOk := StrTran( cTextOk, "â", "" )
	cTextOk := StrTran( cTextOk, "Â", "" )
	cTextOk := StrTran( cTextOk, "ã", "" )
	cTextOk := StrTran( cTextOk, "Ã", "" )
	cTextOk := StrTran( cTextOk, "ä", "" )
	cTextOk := StrTran( cTextOk, "Ä", "" )
	cTextOk := StrTran( cTextOk, "é", "" )
	cTextOk := StrTran( cTextOk, "É", "" )
	cTextOk := StrTran( cTextOk, "è", "" )
	cTextOk := StrTran( cTextOk, "È", "" )
	cTextOk := StrTran( cTextOk, "ê", "" )
	cTextOk := StrTran( cTextOk, "Ê", "" )
	cTextOk := StrTran( cTextOk, "ë", "" )
	cTextOk := StrTran( cTextOk, "Ë", "" )
	cTextOk := StrTran( cTextOk, "í", "" )
	cTextOk := StrTran( cTextOk, "Í", "" )
	cTextOk := StrTran( cTextOk, "ì", "" )
	cTextOk := StrTran( cTextOk, "Ì", "" )
	cTextOk := StrTran( cTextOk, "ï", "" )
	cTextOk := StrTran( cTextOk, "Ï", "" )
	cTextOk := StrTran( cTextOk, "ó", "" )
	cTextOk := StrTran( cTextOk, "ò", "" )
	cTextOk := StrTran( cTextOk, "Ó", "" )
	cTextOk := StrTran( cTextOk, "Ò", "" )
	cTextOk := StrTran( cTextOk, "õ", "" )
	cTextOk := StrTran( cTextOk, "Õ", "" )
	cTextOk := StrTran( cTextOk, "ô", "" )
	cTextOk := StrTran( cTextOk, "Ô", "" )
	cTextOk := StrTran( cTextOk, "ö", "" )
	cTextOk := StrTran( cTextOk, "Ö", "" )
	cTextOk := StrTran( cTextOk, "ú", "" )
	cTextOk := StrTran( cTextOk, "ù", "" )
	cTextOk := StrTran( cTextOk, "Ú", "" )
	cTextOk := StrTran( cTextOk, "Ù", "" )
	cTextOk := StrTran( cTextOk, "û", "" )
	cTextOk := StrTran( cTextOk, "Û", "" )
	cTextOk := StrTran( cTextOk, "ü", "" )
	cTextOk := StrTran( cTextOk, "Ü", "" )
	cTextOk := StrTran( cTextOk, "ç", "" )
	cTextOk := StrTran( cTextOk, "Ç", "" )

Return( cTextOk )
